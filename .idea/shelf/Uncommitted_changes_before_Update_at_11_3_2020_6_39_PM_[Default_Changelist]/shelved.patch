Index: app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.msu.hagopi10.project1;\r\n\r\n\r\nimport android.content.Context;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Paint;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\n\r\nimport java.util.Random;\r\n\r\nimport android.widget.TextView;\r\n\r\n\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * This class represents our checkerboard.\r\n */\r\npublic class CheckerBoard {\r\n\r\n    private Paint textPaint;\r\n    /**\r\n     * Paint for filling the area the checkerboard is in\r\n     */\r\n    private Paint fillPaint;\r\n\r\n    /**\r\n     * Paint for outlining the area the checkerboard is in\r\n     */\r\n    private Paint outlinePaint;\r\n    \r\n\r\n    /**\r\n     * The size of the checkerboard in pixels\r\n     */\r\n    private int checkerSize;\r\n\r\n    /**\r\n     * How much we scale the checkerboard pieces\r\n     */\r\n    private float scaleFactor;\r\n\r\n    /**\r\n     * Left margin in pixels\r\n     */\r\n    private int marginX;\r\n\r\n    /**\r\n     * Top margin in pixels\r\n     */\r\n    private int marginY;\r\n\r\n    /**\r\n     * Most recent relative X touch when dragging\r\n     */\r\n    private float lastRelX;\r\n\r\n    /**\r\n     * Most recent relative Y touch when dragging\r\n     */\r\n    private float lastRelY;\r\n\r\n    /**\r\n     * Collection of checkerboard pieces\r\n     */\r\n    public ArrayList<CheckerPiece> pieces = new ArrayList< >();\r\n\r\n    /**\r\n     * This variable is set to a piece we are dragging. If\r\n     * we are not dragging, the variable is null.\r\n     */\r\n    private CheckerPiece dragging = null;\r\n\r\n    /**\r\n     * Percentage of the display width or height that\r\n     * is occupied by the checkerboard.\r\n     */\r\n    final static float SCALE_IN_VIEW = 0.9f;\r\n\r\n    /**\r\n     * Random number generator\r\n     */\r\n    private static Random random = new Random();\r\n\r\n    /**\r\n     * The name of the bundle keys to save the checkerboard\r\n     */\r\n    private final static String LOCATIONS = \"checkerboard.locations\";\r\n    private final static String IDS = \"checkerboard.ids\";\r\n\r\n    /**\r\n     * Paint color we will use to draw dark checker squares\r\n     */\r\n    private int darkSquare = 0xff779455;\r\n\r\n    /**\r\n     * Paint color we will use to draw light checker squares\r\n     */\r\n    private int lightSquare = 0xffebebd0;\r\n\r\n    /**\r\n     * Current player to make a move\r\n     * 1 = player 1\r\n     * 2 = player 2\r\n     * Starts game with player 1\r\n     */\r\n    private int activePlayer = 1;\r\n\r\n    public int getActivePlayer() {\r\n        return activePlayer;\r\n    }\r\n\r\n    public CheckerBoard(Context context) {\r\n\r\n        // Create paint for filling the area the checkerboard will\r\n        // be solved in.\r\n        fillPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n        fillPaint.setColor(0xccccffcc);\r\n\r\n        outlinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n        outlinePaint.setColor(0xffcccccc);\r\n\r\n\r\n        // Load the checkerboard pieces\r\n\r\n        //pieces.add( new CheckerPiece(context, R.drawable.spartan_green, 12) );\r\n\r\n        //Load green pieces\r\n        for(int i = 0; i<12; i++){\r\n            pieces.add(new CheckerPiece(context, R.drawable.spartan_green, i, 1));\r\n        }\r\n\r\n         //Load white pieces\r\n        for(int i = 0; i<12; i++){\r\n            pieces.add(new CheckerPiece(context, R.drawable.spartan_white, 31-i, 2));\r\n        }\r\n\r\n    }\r\n\r\n    public void draw(Canvas canvas){\r\n        int wid = canvas.getWidth();\r\n        int hit = canvas.getHeight();\r\n\r\n        // Determine the minimum of the two dimensions\r\n        int minDim = wid < hit ? wid : hit;\r\n\r\n        checkerSize = (int)(minDim * SCALE_IN_VIEW);\r\n\r\n        // Compute the margins so we center the puzzle\r\n        marginX = (wid - checkerSize) / 2;\r\n        marginY = (hit - checkerSize) / 2;\r\n        //\r\n        // Draw the outline of the puzzle\r\n        //\r\n\r\n        scaleFactor = (float)checkerSize;\r\n\r\n        canvas.drawRect(marginX, marginY,\r\n                marginX + checkerSize, marginY + checkerSize, fillPaint);\r\n\r\n        for(int i = 0; i < 8; i++){\r\n            drawColumn(canvas, i);\r\n        }\r\n\r\n        //\r\n        // draw the actual pieces\r\n        //\r\n        for(CheckerPiece piece : pieces){\r\n            piece.draw(canvas, marginX, marginY, checkerSize, scaleFactor);\r\n        }\r\n\r\n    }\r\n\r\n    public void drawColumn(Canvas canvas, int columnIndex){\r\n        int wid = canvas.getWidth();\r\n        int hit = canvas.getHeight();\r\n\r\n        // Determine the minimum of the two dimensions\r\n        int minDim = wid < hit ? wid : hit;\r\n\r\n        int puzzleSize = (int)(minDim * SCALE_IN_VIEW);\r\n\r\n        // Compute the margins so we center the puzzle\r\n        int marginX = (wid - puzzleSize) / 2;\r\n        int marginY = (hit - puzzleSize) / 2;\r\n\r\n        for(int i = 0; i< 8; i++){\r\n             int squareCenterXOffset = marginX + columnIndex * puzzleSize/8;\r\n             int squareCenterYOffset = marginY + i * puzzleSize/8;\r\n\r\n             if ((i + columnIndex) % 2 == 1){\r\n                 fillPaint.setColor(darkSquare);\r\n             }\r\n             else{\r\n                 fillPaint.setColor(lightSquare);\r\n             }\r\n\r\n            canvas.drawRect(squareCenterXOffset, squareCenterYOffset,\r\n                    squareCenterXOffset + puzzleSize/8, squareCenterYOffset + puzzleSize/8, fillPaint);\r\n        }\r\n    }\r\n\r\n    private boolean onTouched(float x, float y) {\r\n\r\n        // Check each piece to see if it has been hit\r\n        // We do this in reverse order so we find the pieces in front\r\n        for(int p=pieces.size()-1; p>=0;  p--) {\r\n            if(pieces.get(p).hit(x, y, checkerSize, SCALE_IN_VIEW, marginX, marginY)\r\n                && activePlayer == pieces.get(p).access) {\r\n                // We hit a piece!\r\n\r\n                //dragging = pieces.get(pieces.size()-1);\r\n                dragging = pieces.get(p);\r\n                dragging.isGrabbed = true;\r\n                lastRelX = x;\r\n                lastRelY = y;\r\n                //PuzzlePiece t = pieces.get(pieces.size()-1);\r\n                //pieces.set(p, t);\r\n                //pieces.set(pieces.size()-1, dragging);\r\n                pieces.add(pieces.size(), dragging);\r\n                pieces.remove(p);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /*\r\n     * Handle a touch event from the view.\r\n     * @param view The view that is the source of the touch\r\n     * @param event The motion event describing the touch\r\n     * @return true if the touch is handled.\r\n    *\r\n    */\r\n\r\n    public boolean onTouchEvent(View view, MotionEvent event) {\r\n\r\n        // Convert an x,y location to a relative location in the\r\n        // puzzle.\r\n        //\r\n        float relX = (event.getX()) / (checkerSize + marginX*2);\r\n        float relY = (event.getY()) / (checkerSize + marginY*2);\r\n\r\n        switch (event.getActionMasked()) {\r\n\r\n            case MotionEvent.ACTION_DOWN:\r\n                return onTouched(relX, relY);\r\n\r\n            case MotionEvent.ACTION_UP:\r\n            case MotionEvent.ACTION_CANCEL:\r\n                return onReleased(view, relX, relY);\r\n\r\n\r\n            case MotionEvent.ACTION_MOVE:\r\n                // If we are dragging, move the piece and force a redraw\r\n                if(dragging != null) {\r\n                    //check if valid\r\n                    //dragging.dx = 500;\r\n                    dragging.move(relX - lastRelX, relY - lastRelY);\r\n                    //dragging.move(lastRelX, lastRelY);\r\n                    lastRelX = relX;\r\n                    lastRelY = relY;\r\n\r\n                    view.invalidate();\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Handle a release of a touch message.\r\n     * @param x x location for the touch release, relative to the puzzle - 0 to 1 over the puzzle\r\n     * @param y y location for the touch release, relative to the puzzle - 0 to 1 over the puzzle\r\n     * @return true if the touch is handled\r\n     */\r\n    private boolean onReleased(View view, float x, float y) {\r\n\r\n        if(dragging != null) {\r\n            for (int p=pieces.size()-1; p>=0;  p--){\r\n                CheckerPiece test1 = pieces.get(p);\r\n                int proposedIndex = dragging.calculateIndex(marginX, marginY, checkerSize);\r\n                int currentIndex = test1.calculateIndex(marginX, marginY, checkerSize);\r\n\r\n                if (dragging.locationIndex == pieces.get(p).locationIndex) {\r\n                    if (dragging.locationIndex == pieces.get(p).locationIndex) {\r\n                        //true\r\n                        if (pieces.get(p) != dragging) {\r\n                            return false;\r\n                        }\r\n                        //pieces.remove(p);\r\n                        //return false;\r\n                    }\r\n                }\r\n            }\r\n            int potentialIndex = dragging.calculateIndex(marginX,  marginY,  checkerSize);\r\n            if(dragging.maybeSnap(marginX, marginY, checkerSize)) {\r\n                // We have snapped into place\r\n\r\n                // check if there is  a  piece in the way\r\n                boolean locationOccupied = false;\r\n                //int potentialIndex = dragging.calculateIndex(marginX,  marginY,  checkerSize);\r\n                for(CheckerPiece piece : pieces){\r\n                    if(piece.locationIndex == potentialIndex){\r\n                        locationOccupied = true;\r\n                        break;\r\n                    }\r\n                }\r\n\r\n                if(!locationOccupied)  {\r\n                    dragging.updateIndex(potentialIndex, marginX, marginY, checkerSize);\r\n\r\n                    if(isDone()) {\r\n                        // The puzzle is done\r\n\r\n                    }\r\n                    else{\r\n                        switchTurn(view);\r\n                    }\r\n                }\r\n                else{\r\n                    // if move fails, reset x and y\r\n\r\n\r\n                }\r\n\r\n\r\n                view.invalidate();\r\n            }\r\n            else if(!(potentialIndex<0 || potentialIndex>31) ) {\r\n                // check for jump before failure\r\n                //int potentialIndex = dragging.calculateIndex(marginX,  marginY,  checkerSize);\r\n                int potentialJumpee = -1;\r\n                switch(dragging.locationIndex - potentialIndex){\r\n                    case 7:\r\n                        if( (dragging.locationIndex/4)%2 == 0 ){\r\n                            // if player 1, use 4 if player 2 use 3\r\n                            potentialJumpee = dragging.access == 1 ? 4 : 3;\r\n                        }\r\n                        else{\r\n                            // if player 1, use 3 if player 2 use 4\r\n                            potentialJumpee = dragging.access == 1 ? 3 : 4;\r\n                        }\r\n                        break;\r\n                    case 9:\r\n                        if( (dragging.locationIndex/4)%2 == 0 ){\r\n                            // if player 1, use 4 if player 2 use 5\r\n                            potentialJumpee = dragging.access == 1 ? 5 : 4;\r\n                        }\r\n                        else{\r\n                            // if player 1, use 5 if player 2 use 4\r\n                            potentialJumpee = dragging.access == 1 ? 4 : 5;\r\n                        }\r\n                        break;\r\n                }\r\n                if(!(potentialJumpee == -1)){  // if valid and/or not\r\n                    for(CheckerPiece piece : pieces){\r\n                        if( (dragging.access == 1 && (dragging.locationIndex + potentialJumpee) == piece.locationIndex)\r\n                         || (dragging.access == 2 && (dragging.locationIndex - potentialJumpee) == piece.locationIndex))\r\n                        {\r\n                            // kill piece\r\n                            pieces.remove(piece);\r\n                            // move dragging\r\n                            dragging.updateIndex(potentialIndex, marginX, marginY, checkerSize);\r\n                            switchTurn(view);\r\n                            break;\r\n                        }\r\n                    }\r\n\r\n                }\r\n\r\n            }\r\n            dragging.isGrabbed = false;\r\n            dragging = null;\r\n\r\n            view.invalidate();\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if the puzzle is done!\r\n     * @return true if puzzle is done\r\n     */\r\n    public boolean isDone() {\r\n        if (pieces.isEmpty()) return true;\r\n        return false;\r\n    }\r\n\r\n    private void switchTurn(View view){\r\n        // swap current player\r\n        activePlayer = activePlayer == 1 ? 2 : 1;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java	(revision 34bc53d44ca4b285726898c8fd3e807dede8c27c)
+++ app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java	(date 1604446573725)
@@ -335,7 +335,7 @@
                 // check for jump before failure
                 //int potentialIndex = dragging.calculateIndex(marginX,  marginY,  checkerSize);
                 int potentialJumpee = -1;
-                switch(dragging.locationIndex - potentialIndex){
+                switch(Math.abs(dragging.locationIndex - potentialIndex)){
                     case 7:
                         if( (dragging.locationIndex/4)%2 == 0 ){
                             // if player 1, use 4 if player 2 use 3
