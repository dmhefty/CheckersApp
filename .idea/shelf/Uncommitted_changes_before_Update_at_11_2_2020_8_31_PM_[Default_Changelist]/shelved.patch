Index: app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.msu.hagopi10.project1;\r\n\r\n\r\nimport android.content.Context;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Paint;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\nimport android.app.AlertDialog;\r\nimport java.util.Random;\r\nimport android.os.Bundle;\r\nimport android.content.DialogInterface;\r\n\r\n\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * This class represents our checkerboard.\r\n */\r\npublic class CheckerBoard {\r\n\r\n    private Paint textPaint;\r\n    /**\r\n     * Paint for filling the area the checkerboard is in\r\n     */\r\n    private Paint fillPaint;\r\n\r\n    /**\r\n     * Paint for outlining the area the checkerboard is in\r\n     */\r\n    private Paint outlinePaint;\r\n    \r\n\r\n    /**\r\n     * The size of the checkerboard in pixels\r\n     */\r\n    private int checkerSize;\r\n\r\n    /**\r\n     * How much we scale the checkerboard pieces\r\n     */\r\n    private float scaleFactor;\r\n\r\n    /**\r\n     * Left margin in pixels\r\n     */\r\n    private int marginX;\r\n\r\n    /**\r\n     * Top margin in pixels\r\n     */\r\n    private int marginY;\r\n\r\n    private float xCoordinate;\r\n\r\n    private float yCoordinate;\r\n\r\n    /**\r\n     * Most recent relative X touch when dragging\r\n     */\r\n    private float lastRelX;\r\n\r\n    //gameSize = int(minDim) * SCALE_IN_VIEW;\r\n\r\n    //blockSize = gameSize /8\r\n    /**\r\n     * Most recent relative Y touch when dragging\r\n     */\r\n    private float lastRelY;\r\n\r\n    /**\r\n     * Collection of checkerboard pieces\r\n     */\r\n    public ArrayList<CheckerPiece> pieces = new ArrayList< >();\r\n\r\n    /**\r\n     * This variable is set to a piece we are dragging. If\r\n     * we are not dragging, the variable is null.\r\n     */\r\n    private CheckerPiece dragging = null;\r\n\r\n    /**\r\n     * Percentage of the display width or height that\r\n     * is occupied by the checkerboard.\r\n     */\r\n    final static float SCALE_IN_VIEW = 0.9f;\r\n\r\n    /**\r\n     * Random number generator\r\n     */\r\n    private static Random random = new Random();\r\n\r\n    /**\r\n     * The name of the bundle keys to save the checkerboard\r\n     */\r\n    private final static String LOCATIONS = \"checkerboard.locations\";\r\n    private final static String IDS = \"checkerboard.ids\";\r\n\r\n    /**\r\n     * Paint color we will use to draw dark checker squares\r\n     */\r\n    private int darkSquare = 0xff779455;\r\n\r\n    /**\r\n     * Paint color we will use to draw light checker squares\r\n     */\r\n    private int lightSquare = 0xffebebd0;\r\n\r\n\r\n    public CheckerBoard(Context context) {\r\n\r\n        // Create paint for filling the area the checkerboard will\r\n        // be solved in.\r\n        fillPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n        fillPaint.setColor(0xffcccccc);\r\n\r\n        outlinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n        outlinePaint.setColor(0xccccffcc);\r\n\r\n\r\n        // Load the checkerboard pieces\r\n\r\n        pieces.add( new CheckerPiece(context, R.drawable.spartan_green, 12) );\r\n\r\n        // Load green pieces\r\n        //for(int i = 0; i<12; i++){\r\n        //    pieces.add(new CheckerPiece(context, R.drawable.spartan_green, i));\r\n        //}\r\n\r\n        // Load white pieces\r\n        //for(int i = 0; i<12; i++){\r\n        //    pieces.add(new CheckerPiece(context, R.drawable.spartan_white, 31-i));\r\n        //}\r\n\r\n    }\r\n\r\n    public void draw(Canvas canvas){\r\n        int wid = canvas.getWidth();\r\n        int hit = canvas.getHeight();\r\n\r\n        // Determine the minimum of the two dimensions\r\n        int minDim = wid < hit ? wid : hit;\r\n\r\n        checkerSize = (int)(minDim * SCALE_IN_VIEW);\r\n\r\n        // Compute the margins so we center the puzzle\r\n        marginX = (wid - checkerSize) / 2;\r\n        marginY = (hit - checkerSize) / 2;\r\n        //\r\n        // Draw the outline of the puzzle\r\n        //\r\n\r\n        scaleFactor = (float)checkerSize;\r\n\r\n        canvas.drawRect(marginX, marginY,\r\n                marginX + checkerSize, marginY + checkerSize, fillPaint);\r\n\r\n        for(int i = 0; i < 8; i++){\r\n            drawColumn(canvas, i);\r\n        }\r\n\r\n        //\r\n        // draw the actual pieces\r\n        //\r\n        for(CheckerPiece piece : pieces){\r\n            piece.draw(canvas, marginX, marginY, checkerSize, scaleFactor);\r\n        }\r\n\r\n    }\r\n\r\n/*\r\n        if (dragging != null) {\r\n            dragging.draw_dragging(canvas, blockSize, xCoordinate, yCoordinate);\r\n        }\r\n        */\r\n\r\n\r\n    /*\r\n        public draw_dragging(canvas, blockSize, xCoordinate, yCoordinate) {\r\n            canvas.save();\r\n\r\n            canvas.translate(i, i)\r\n\r\n                    canvas.scale()\r\n        }\r\n    */\r\n    public void drawColumn(Canvas canvas, int columnIndex){\r\n        int wid = canvas.getWidth();\r\n        int hit = canvas.getHeight();\r\n\r\n        // Determine the minimum of the two dimensions\r\n        int minDim = wid < hit ? wid : hit;\r\n\r\n        int puzzleSize = (int)(minDim * SCALE_IN_VIEW);\r\n\r\n        // Compute the margins so we center the puzzle\r\n        int marginX = (wid - puzzleSize) / 2;\r\n        int marginY = (hit - puzzleSize) / 2;\r\n\r\n        for(int i = 0; i< 8; i++){\r\n             int squareCenterXOffset = marginX + columnIndex * puzzleSize/8;\r\n             int squareCenterYOffset = marginY + i * puzzleSize/8;\r\n\r\n             if ((i + columnIndex) % 2 == 0){\r\n                 fillPaint.setColor(darkSquare);\r\n             }\r\n             else{\r\n                 fillPaint.setColor(lightSquare);\r\n             }\r\n\r\n            canvas.drawRect(squareCenterXOffset, squareCenterYOffset,\r\n                    squareCenterXOffset + puzzleSize/8, squareCenterYOffset + puzzleSize/8, fillPaint);\r\n        }\r\n    }\r\n\r\n    private boolean onTouched(float x, float y) {\r\n\r\n        // Check each piece to see if it has been hit\r\n        // We do this in reverse order so we find the pieces in front\r\n        for(int p=pieces.size()-1; p>=0;  p--) {\r\n            if(pieces.get(p).hit(x, y, checkerSize, SCALE_IN_VIEW)) {\r\n                // We hit a piece!\r\n\r\n                //dragging = pieces.get(pieces.size()-1);\r\n                dragging = pieces.get(p);\r\n                dragging.isGrabbed = true;\r\n                lastRelX = x;\r\n                lastRelY = y;\r\n                //PuzzlePiece t = pieces.get(pieces.size()-1);\r\n                //pieces.set(p, t);\r\n                //pieces.set(pieces.size()-1, dragging);\r\n                //pieces.add(pieces.size(), dragging);\r\n                //pieces.remove(p);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /*\r\n     * Handle a touch event from the view.\r\n     * @param view The view that is the source of the touch\r\n     * @param event The motion event describing the touch\r\n     * @return true if the touch is handled.\r\n    *\r\n    */\r\n\r\n    public boolean onTouchEvent(View view, MotionEvent event) {\r\n\r\n        // Convert an x,y location to a relative location in the\r\n        // puzzle.\r\n        //\r\n        xCoordinate = event.getX();\r\n        yCoordinate = event.getY();\r\n\r\n        float relX = (event.getX() - marginX) / checkerSize;\r\n        float relY = (event.getY() - marginY) / checkerSize;\r\n\r\n        switch (event.getActionMasked()) {\r\n\r\n            case MotionEvent.ACTION_DOWN:\r\n                return onTouched(relX, relY);\r\n\r\n            case MotionEvent.ACTION_UP:\r\n            case MotionEvent.ACTION_CANCEL:\r\n                return onReleased(view, relX, relY);\r\n\r\n            case MotionEvent.ACTION_MOVE:\r\n                // If we are dragging, move the piece and force a redraw\r\n                if(dragging != null) {\r\n                    //check if valid\r\n                    //dragging.dx = 500;\r\n                    dragging.move(relX - lastRelX, relY - lastRelY);\r\n                    //dragging.move(lastRelX, lastRelY);\r\n                    lastRelX = relX;\r\n                    lastRelY = relY;\r\n\r\n                    view.invalidate();\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Handle a release of a touch message.\r\n     * @param x x location for the touch release, relative to the puzzle - 0 to 1 over the puzzle\r\n     * @param y y location for the touch release, relative to the puzzle - 0 to 1 over the puzzle\r\n     * @return true if the touch is handled\r\n     */\r\n    private boolean onReleased(View view, float x, float y) {\r\n\r\n\r\n        dragging.move(lastRelX, lastRelY);\r\n        if(dragging != null) {\r\n            dragging.isGrabbed = false;\r\n            dragging = null;\r\n\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n}\r\n\r\n\r\n// test!!!!!
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java	(revision 0082f6e8560d0c49b226869da88efe6f0fb5cf23)
+++ app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java	(date 1604366935985)
@@ -122,17 +122,17 @@
 
         // Load the checkerboard pieces
 
-        pieces.add( new CheckerPiece(context, R.drawable.spartan_green, 12) );
+        //pieces.add( new CheckerPiece(context, R.drawable.spartan_green, 12) );
 
         // Load green pieces
-        //for(int i = 0; i<12; i++){
-        //    pieces.add(new CheckerPiece(context, R.drawable.spartan_green, i));
-        //}
+        for(int i = 0; i<12; i++){
+            pieces.add(new CheckerPiece(context, R.drawable.spartan_green, i));
+        }
 
         // Load white pieces
-        //for(int i = 0; i<12; i++){
-        //    pieces.add(new CheckerPiece(context, R.drawable.spartan_white, 31-i));
-        //}
+        for(int i = 0; i<12; i++){
+            pieces.add(new CheckerPiece(context, R.drawable.spartan_white, 31-i));
+        }
 
     }
 
@@ -257,8 +257,8 @@
         xCoordinate = event.getX();
         yCoordinate = event.getY();
 
-        float relX = (event.getX() - marginX) / checkerSize;
-        float relY = (event.getY() - marginY) / checkerSize;
+        float relX = (event.getX() - marginX) / (checkerSize+ 2*marginX);
+        float relY = (event.getY() - marginY) / (checkerSize+ 2*marginY);
 
         switch (event.getActionMasked()) {
 
