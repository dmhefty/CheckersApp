Index: app/src/main/java/edu/msu/hagopi10/project1/CheckerPiece.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.msu.hagopi10.project1;\r\n\r\nimport android.content.Context;\r\nimport android.database.CrossProcessCursorWrapper;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport java.util.Random;\r\nimport android.graphics.Paint;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\n\r\npublic class CheckerPiece {\r\n    /**\r\n     * THe image for the actual piece.\r\n     */\r\n    private Bitmap piece;\r\n\r\n    public float getX() {\r\n        return x;\r\n    }\r\n\r\n    public void setX(float x) {\r\n        this.x = x;\r\n    }\r\n\r\n    public float getY() {\r\n        return y;\r\n    }\r\n\r\n    public void setY(float y) {\r\n        this.y = y;\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * The piece ID\r\n     */\r\n    private int id;\r\n\r\n    /**\r\n     * x location.\r\n     * We use relative x locations in the range 0-1 for the center\r\n     * of the puzzle piece.\r\n     */\r\n    private float x = 0;\r\n\r\n    /**\r\n     * y location\r\n     */\r\n    private float y = 0;\r\n\r\n    /**\r\n     * x location when the puzzle is solved\r\n     */\r\n    private float finalX;\r\n\r\n    /**\r\n     * y location when the puzzle is solved\r\n     */\r\n    private float finalY;\r\n\r\n    /**\r\n     * y location when the puzzle is solved\r\n     */\r\n    private Paint textPaint;\r\n\r\n    /**\r\n     * We consider a piece to be in the right location if within\r\n     * this distance.\r\n     */\r\n    final static float SNAP_DISTANCE = .07f;\r\n\r\n    /**\r\n     * What square the piece is in, starts counting from the top, leftmost, square, counts right\r\n     * until the end of the row then loops to the leftmost square on the next row and continues\r\n     * counting\r\n     */\r\n    public int locationIndex;\r\n\r\n    /**\r\n     * True when the piece has been picked up to move\r\n     */\r\n    public boolean isGrabbed;\r\n\r\n    /**\r\n     * Which player can grab this piece\r\n     * 1 is player 1, 2 is player 2\r\n     */\r\n    public int access;\r\n\r\n    public CheckerPiece(Context context, int id, int boardIndex, int access) {\r\n        this.locationIndex = boardIndex;\r\n        this.id = id;\r\n        this.access = access;\r\n\r\n        piece = BitmapFactory.decodeResource(context.getResources(), id);\r\n\r\n    }\r\n\r\n    public void draw(Canvas canvas, int marginX, int marginY,\r\n                     int puzzleSize, float scaleFactor){\r\n\r\n        if (!isGrabbed) setLocationFromIndex(locationIndex, marginX, marginY, puzzleSize);\r\n\r\n        canvas.save();\r\n\r\n        // Convert x,y to pixels and add the margin, then draw\r\n        canvas.translate(x * (puzzleSize + 2*marginX), y * (puzzleSize + 2*marginY));\r\n\r\n        scaleFactor = (puzzleSize/8.0f)/(float)Math.min(piece.getHeight(), piece.getWidth());\r\n\r\n        // Scale it to the right size\r\n        canvas.scale(scaleFactor, scaleFactor);\r\n\r\n        // This magic code makes the center of the piece at 0, 0\r\n        canvas.translate(-piece.getWidth() / 2f, -piece.getHeight() / 2f);\r\n\r\n        // Draw the bitmap\r\n        canvas.drawBitmap(piece, 0, 0, null);\r\n        canvas.restore();\r\n\r\n    }\r\n\r\n    /**\r\n     * Test to see if we have touched a puzzle piece\r\n     * @param testX X location as a normalized coordinate (0 to 1)\r\n     * @param testY Y location as a normalized coordinate (0 to 1)\r\n     * @param puzzleSize the size of the puzzle in pixels\r\n     * @param scaleFactor the amount to scale a piece by\r\n     * @return true if we hit the piece\r\n     */\r\n    public boolean hit(float testX, float testY,\r\n                       int puzzleSize, float scaleFactor, int marginX, int marginY) {\r\n\r\n        // Make relative to the location and size to the piece size\r\n        scaleFactor = (puzzleSize/8.0f)/(float)Math.min(piece.getHeight(), piece.getWidth());\r\n\r\n        int pX = (int)(( ((testX - x) * (puzzleSize + marginX*2)) +\r\n                piece.getWidth() * 3f/8f));\r\n        int pY = (int)(( ((testY - y) * (puzzleSize + marginY*2)) +\r\n                piece.getHeight() * 3f/8f));\r\n\r\n        if(pX < 0 || pX >= piece.getWidth()/2 ||\r\n                pY < 0 || pY >= piece.getHeight()/2) {\r\n            return false;\r\n        }\r\n\r\n        // We are within the rectangle of the piece.\r\n        // Are we touching actual picture?\r\n        return (piece.getPixel(pX, pY) & 0xff000000) != 0;\r\n\r\n    }\r\n\r\n    /**\r\n     * Move the puzzle piece by dx, dy\r\n     * @param dx x amount to move\r\n     * @param dy y amount to move\r\n     */\r\n    public void move(float dx, float dy) {\r\n        x += dx;\r\n        y += dy;\r\n    }\r\n\r\n    public void setLocationFromIndex(int index, int marginX, int marginY, int puzzleSize){\r\n        int xIndex; int yIndex;\r\n        xIndex = index%4;\r\n        yIndex = index/4;\r\n\r\n        // Convert x,y to pixels and add the margin, then draw\r\n        if( yIndex%2 == 0 ){\r\n            x = (float) (marginX + xIndex * puzzleSize/4 + puzzleSize * 3/16) / (float) (puzzleSize + 2*marginX);\r\n            y = (float) (marginY + yIndex * puzzleSize/8 + puzzleSize/16) / (float) (puzzleSize + 2*marginY);\r\n        }\r\n        else{\r\n            x = (float) (marginX + xIndex * puzzleSize/4 + puzzleSize/16) / (float) (puzzleSize + 2*marginX);\r\n            y = (float) (marginY + yIndex * puzzleSize/8 + puzzleSize/16) / (float) (puzzleSize + 2*marginY);\r\n        }\r\n\r\n    }\r\n\r\n    public int calculateIndex(int marginX, int marginY, int puzzleSize) {\r\n\r\n        int colIndex; int rowIndex;\r\n        //gets row (y) index\r\n        rowIndex = (int) (((float) ((y)*(puzzleSize + 2*marginY) - marginY) / (float) (puzzleSize/8)));\r\n\r\n        // find column (x) index based on if it should be shifted over\r\n        if( rowIndex%2 == 0 ){\r\n            colIndex = (int) ((x*(puzzleSize + 2*marginX) - marginX) / (puzzleSize/4));\r\n\r\n        }\r\n        else{\r\n            colIndex = (int) ((x*(puzzleSize + 2*marginX) + (puzzleSize* 1/16) - marginX) / (puzzleSize/4));\r\n        }\r\n\r\n        return rowIndex*4 + colIndex;\r\n    }\r\n\r\n    public boolean isValid(int index) {\r\n        //compute if there is a piece at index.\r\n        //if there is friendly piece at index, return false\r\n        //else, there must be either no piece or an enemy piece\r\n        //if there is an enemy piece, delete that piece, and return true\r\n        //if there is no piece, return true\r\n        return true;\r\n    }\r\n    /**\r\n     * If we are within SNAP_DISTANCE of the correct\r\n     * answer, snap to the correct answer exactly.\r\n     * @return\r\n     */\r\n    public boolean maybeSnap(int marginX, int marginY, int puzzleSize) {\r\n\r\n\r\n        int index = calculateIndex(marginX, marginY, puzzleSize);\r\n\r\n        // location must be greater than 0\r\n        // if player 1 and piece isn't a king, it must move down\r\n        // if player 2 and piece isn't a king, it must move upward\r\n        if(index >= 0\r\n                && ((access == 1 && index/4 > locationIndex/4 && (index ==  locationIndex+4 || index == locationIndex+5))\r\n                ||  (access == 2 && index/4 < locationIndex/4 && (index ==  locationIndex-4 || index == locationIndex-5))))\r\n        {\r\n\r\n\r\n            if (isValid(index)) {\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if this piece is snapped in place\r\n     * @return true if snapped into place\r\n     */\r\n    public boolean isSnapped() {\r\n        if (x == finalX && y == finalY) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * words\r\n     */\r\n    public void updateIndex(int index){\r\n        locationIndex = index;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/msu/hagopi10/project1/CheckerPiece.java	(revision a6ecc386c5eed9628cd85f2e6dfacedbe815d513)
+++ app/src/main/java/edu/msu/hagopi10/project1/CheckerPiece.java	(date 1604442093179)
@@ -223,8 +223,8 @@
         // if player 1 and piece isn't a king, it must move down
         // if player 2 and piece isn't a king, it must move upward
         if(index >= 0
-                && ((access == 1 && index/4 > locationIndex/4 && (index ==  locationIndex+4 || index == locationIndex+5))
-                ||  (access == 2 && index/4 < locationIndex/4 && (index ==  locationIndex-4 || index == locationIndex-5))))
+                && ((access == 1 && index/4 > locationIndex/4 && (index ==  locationIndex+4 || index == locationIndex+5 || index == locationIndex+3))
+                ||  (access == 2 && index/4 < locationIndex/4 && (index ==  locationIndex-4 || index == locationIndex-5 || index == locationIndex-3))))
         {
 
 
@@ -248,10 +248,39 @@
         return false;
     }
 
-    /**
+    /**z
      * words
      */
-    public void updateIndex(int index){
+    public void updateIndex(int index, int marginX, int marginY, int puzzleSize){
         locationIndex = index;
+        setLocationFromIndex(index, marginX, marginY, puzzleSize);
+    }
+
+    /**
+     * Determine if the move is a valid jump.
+     * @param marginX margin of x axis in pixels
+     * @param marginY margin of y axis in pixels
+     * @param puzzleSize puzzle size in pixels
+     * @return
+     */
+    public boolean checkJump(int marginX, int marginY, int puzzleSize){
+        int index = calculateIndex(marginX, marginY, puzzleSize);
+
+        // location must be greater than 0
+        // if player 1 and piece isn't a king, it must move down
+        // if player 2 and piece isn't a king, it must move upward
+        if(index >= 0
+                && ((access == 1 && index/4 > locationIndex/4 && (index ==  locationIndex+7 || index == locationIndex+8 || index == locationIndex+9))
+                ||  (access == 2 && index/4 < locationIndex/4 && (index ==  locationIndex-7 || index == locationIndex-8 || index == locationIndex-9))))
+        {
+
+
+            if (isValid(index)) {
+                return true;
+            }
+
+        }
+
+        return false;
     }
 }
Index: app/src/main/java/edu/msu/hagopi10/project1/CheckersActivity.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.msu.hagopi10.project1;\r\n\r\nimport androidx.appcompat.app.AppCompatActivity;\r\n\r\nimport android.app.AlertDialog;\r\nimport android.os.Bundle;\r\nimport android.view.View;\r\nimport android.widget.TextView;\r\n\r\npublic class CheckersActivity extends AppCompatActivity {\r\n    public int score1 = 12;\r\n    public int score2 = 12;\r\n    Player Player1 = new Player(1,score1);\r\n    Player Player2 = new Player(2,score2);\r\n\r\n\r\n    @Override\r\n    protected void onCreate(Bundle savedInstanceState) {\r\n        super.onCreate(savedInstanceState);\r\n        setContentView(R.layout.activity_checkers);\r\n\r\n        TextView playerName = (TextView)findViewById(R.id.player1);\r\n        playerName.setText(MainActivity.nameS1);\r\n\r\n        TextView p2Name = (TextView)findViewById(R.id.player2);\r\n        p2Name.setText(MainActivity.nameS2);\r\n    }\r\n\r\n    public void EndTurn(View view) {\r\n        if (score1 <= 0) {\r\n            TextView p2Name = (TextView)findViewById(R.id.player2);\r\n            p2Name.setText(MainActivity.nameS2);\r\n\r\n            AlertDialog.Builder builder =\r\n                    new AlertDialog.Builder(view.getContext());\r\n\r\n            // Parameterize the builder\r\n            builder.setTitle(R.string.gameover);\r\n            builder.setMessage(Player1.GetName1() + \" wins!\");\r\n            builder.setPositiveButton(android.R.string.ok, null);\r\n            // Create the dialog box and show it\r\n            AlertDialog alertDialog = builder.create();\r\n            alertDialog.show();\r\n        }\r\n        else if (score2 <= 0) {\r\n            TextView playerName = (TextView)findViewById(R.id.player1);\r\n            playerName.setText(MainActivity.nameS1);\r\n\r\n            AlertDialog.Builder builder =\r\n                    new AlertDialog.Builder(view.getContext());\r\n\r\n            // Parameterize the builder\r\n            builder.setTitle(R.string.gameover);\r\n            builder.setMessage(Player2.GetName1() + \" wins!\");\r\n            builder.setPositiveButton(android.R.string.ok, null);\r\n            // Create the dialog box and show it\r\n            AlertDialog alertDialog = builder.create();\r\n            alertDialog.show();\r\n        }\r\n    }\r\n\r\n    public void Forfeit(View view) {\r\n        /*if (board.getActivePlayer() == 1) {\r\n\r\n        }\r\n        */\r\n        AlertDialog.Builder builder =\r\n                new AlertDialog.Builder(view.getContext());\r\n\r\n        // Parameterize the builder\r\n        builder.setTitle(R.string.gameover);\r\n        builder.setMessage(R.string.forfeit_message);\r\n        builder.setPositiveButton(android.R.string.ok, null);\r\n        // Create the dialog box and show it\r\n        AlertDialog alertDialog = builder.create();\r\n        alertDialog.show();\r\n    }\r\n\r\n\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/msu/hagopi10/project1/CheckersActivity.java	(revision a6ecc386c5eed9628cd85f2e6dfacedbe815d513)
+++ app/src/main/java/edu/msu/hagopi10/project1/CheckersActivity.java	(date 1604445424671)
@@ -24,6 +24,7 @@
 
         TextView p2Name = (TextView)findViewById(R.id.player2);
         p2Name.setText(MainActivity.nameS2);
+
     }
 
     public void EndTurn(View view) {
Index: app/src/main/java/edu/msu/hagopi10/project1/CheckersView.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.msu.hagopi10.project1;\r\n\r\nimport android.content.Context;\r\nimport android.content.res.TypedArray;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Color;\r\nimport android.graphics.Paint;\r\nimport android.graphics.drawable.Drawable;\r\nimport android.text.TextPaint;\r\nimport android.text.method.Touch;\r\nimport android.util.AttributeSet;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\n\r\nimport java.io.Serializable;\r\nimport java.security.Policy;\r\n\r\n\r\n/**\r\n * Custom view class for our Checkers.\r\n */\r\npublic class CheckersView extends View {\r\n\r\n\r\n    private CheckerBoard board;\r\n\r\n\r\n    /**\r\n     * Paint object we will use to draw a line\r\n     */\r\n    private Paint linePaint;\r\n\r\n    /**\r\n     * First touch status\r\n     */\r\n    private Touch touch1 = new Touch();\r\n\r\n    private Parameters params = new Parameters();\r\n\r\n    /**\r\n     * The image bitmap. None initially.\r\n     */\r\n    private Bitmap imageBitmap = null;\r\n    /**\r\n     * Image drawing scale\r\n     */\r\n    private float imageScale = 1;\r\n\r\n    /**\r\n     * Image left margin in pixels\r\n     */\r\n    private float marginLeft = 0;\r\n\r\n    /**\r\n     * Image top margin in pixels\r\n     */\r\n    private float marginTop = 0;\r\n\r\n    private static class Parameters implements Serializable {\r\n        /**\r\n         * Path to the image file if one exists\r\n         */\r\n        public String imagePath = null;\r\n        /**\r\n         * The current checker type\r\n         */\r\n        public int checker;\r\n        /**\r\n         * X location of hat relative to the image\r\n         */\r\n        public float posX = 0;\r\n        /**\r\n         * Y location of hat relative to the image\r\n         */\r\n        public float posY = 0;\r\n\r\n    }\r\n\r\n    /**\r\n     * Local class to handle the touch status for one touch.\r\n     * We will have one object of this type for each of the\r\n     * two possible touches.\r\n     */\r\n    private static class Touch {\r\n        /**\r\n         * Touch id\r\n         */\r\n        public int id = -1;\r\n\r\n        /**\r\n         * Current x location\r\n         */\r\n        public float x = 0;\r\n\r\n        /**\r\n         * Current y location\r\n         */\r\n        public float y = 0;\r\n\r\n        /**\r\n         * Previous x location\r\n         */\r\n        public float lastX = 0;\r\n\r\n        /**\r\n         * Previous y location\r\n         */\r\n        public float lastY = 0;\r\n        /**\r\n         * Change in x value from previous\r\n         */\r\n        public float dX = 0;\r\n\r\n        /**\r\n         * Change in y value from previous\r\n         */\r\n        public float dY = 0;\r\n        /**\r\n         * Copy the current values to the previous values\r\n         */\r\n        public void copyToLast() {\r\n            lastX = x;\r\n            lastY = y;\r\n        }\r\n        /**\r\n         * Compute the values of dX and dY\r\n         */\r\n        public void computeDeltas() {\r\n            dX = x - lastX;\r\n            dY = y - lastY;\r\n        }\r\n    }\r\n\r\n    public CheckersView(Context context) {\r\n        super(context);\r\n        init(null, 0);\r\n    }\r\n\r\n    public CheckersView(Context context, AttributeSet attrs) {\r\n        super(context, attrs);\r\n        init(attrs, 0);\r\n    }\r\n\r\n    public CheckersView(Context context, AttributeSet attrs, int defStyle) {\r\n        super(context, attrs, defStyle);\r\n        init(attrs, defStyle);\r\n    }\r\n\r\n    private void init(AttributeSet attrs, int defStyle) {\r\n        board = new CheckerBoard(getContext());\r\n    }\r\n\r\n    @Override\r\n    public boolean onTouchEvent(MotionEvent event) {\r\n        return board.onTouchEvent(this, event);\r\n        //return true\r\n    }\r\n\r\n    /**\r\n     * Handle movement of the touches\r\n     */\r\n    private void move() {\r\n        // If no touch1, we have nothing to do\r\n        // This should not happen, but it never hurts\r\n        // to check.\r\n        if(touch1.id < 0) {\r\n            return;\r\n        }\r\n\r\n        // At least one touch\r\n        // We are moving\r\n        touch1.computeDeltas();\r\n\r\n\r\n        params.posX += touch1.dX;\r\n        params.posY += touch1.dY;\r\n    }\r\n\r\n\r\n    @Override\r\n    protected void onDraw(Canvas canvas) {\r\n        super.onDraw(canvas);\r\n\r\n        board.draw(canvas);\r\n    }\r\n\r\n    public boolean hitTest(float x, float y) {\r\n        return true;\r\n    }\r\n    /**\r\n     * Handle a touch event\r\n     * @param event The touch event\r\n     * on release function - check if valid first\r\n     */\r\n\r\n    @Override\r\n    public boolean performClick() {\r\n        return super.performClick();\r\n    }\r\n\r\n    /**\r\n     * Get the positions for the two touches and put them\r\n     * into the appropriate touch objects.\r\n     * @param event the motion event\r\n     */\r\n    private void getPositions(MotionEvent event) {\r\n        for(int i=0;  i<event.getPointerCount();  i++) {\r\n\r\n            // Get the pointer id\r\n            int id = event.getPointerId(i);\r\n\r\n            // Convert to image coordinates\r\n            float x = (event.getX(i) - marginLeft) / imageScale;\r\n            float y = (event.getY(i) - marginTop) / imageScale;\r\n\r\n            if(id == touch1.id) {\r\n                touch1.copyToLast();\r\n                touch1.x = x;\r\n                touch1.y = y;\r\n            }\r\n        }\r\n\r\n        invalidate();\r\n    }\r\n\r\n    public CheckerBoard getBoard() {\r\n        return board;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/msu/hagopi10/project1/CheckersView.java	(revision a6ecc386c5eed9628cd85f2e6dfacedbe815d513)
+++ app/src/main/java/edu/msu/hagopi10/project1/CheckersView.java	(date 1604445401344)
@@ -25,7 +25,6 @@
 
     private CheckerBoard board;
 
-
     /**
      * Paint object we will use to draw a line
      */
Index: app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.msu.hagopi10.project1;\r\n\r\n\r\nimport android.content.Context;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Paint;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\n\r\nimport java.util.Random;\r\n\r\nimport android.widget.TextView;\r\n\r\n\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * This class represents our checkerboard.\r\n */\r\npublic class CheckerBoard {\r\n\r\n    private Paint textPaint;\r\n    /**\r\n     * Paint for filling the area the checkerboard is in\r\n     */\r\n    private Paint fillPaint;\r\n\r\n    /**\r\n     * Paint for outlining the area the checkerboard is in\r\n     */\r\n    private Paint outlinePaint;\r\n    \r\n\r\n    /**\r\n     * The size of the checkerboard in pixels\r\n     */\r\n    private int checkerSize;\r\n\r\n    /**\r\n     * How much we scale the checkerboard pieces\r\n     */\r\n    private float scaleFactor;\r\n\r\n    /**\r\n     * Left margin in pixels\r\n     */\r\n    private int marginX;\r\n\r\n    /**\r\n     * Top margin in pixels\r\n     */\r\n    private int marginY;\r\n\r\n    /**\r\n     * Most recent relative X touch when dragging\r\n     */\r\n    private float lastRelX;\r\n\r\n    /**\r\n     * Most recent relative Y touch when dragging\r\n     */\r\n    private float lastRelY;\r\n\r\n    /**\r\n     * Collection of checkerboard pieces\r\n     */\r\n    public ArrayList<CheckerPiece> pieces = new ArrayList< >();\r\n\r\n    /**\r\n     * This variable is set to a piece we are dragging. If\r\n     * we are not dragging, the variable is null.\r\n     */\r\n    private CheckerPiece dragging = null;\r\n\r\n    /**\r\n     * Percentage of the display width or height that\r\n     * is occupied by the checkerboard.\r\n     */\r\n    final static float SCALE_IN_VIEW = 0.9f;\r\n\r\n    /**\r\n     * Random number generator\r\n     */\r\n    private static Random random = new Random();\r\n\r\n    /**\r\n     * The name of the bundle keys to save the checkerboard\r\n     */\r\n    private final static String LOCATIONS = \"checkerboard.locations\";\r\n    private final static String IDS = \"checkerboard.ids\";\r\n\r\n    /**\r\n     * Paint color we will use to draw dark checker squares\r\n     */\r\n    private int darkSquare = 0xff779455;\r\n\r\n    /**\r\n     * Paint color we will use to draw light checker squares\r\n     */\r\n    private int lightSquare = 0xffebebd0;\r\n\r\n    /**\r\n     * Current player to make a move\r\n     * 1 = player 1\r\n     * 2 = player 2\r\n     * Starts game with player 1\r\n     */\r\n    private int activePlayer = 1;\r\n\r\n    public int getActivePlayer() {\r\n        return activePlayer;\r\n    }\r\n\r\n    public CheckerBoard(Context context) {\r\n\r\n        // Create paint for filling the area the checkerboard will\r\n        // be solved in.\r\n        fillPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n        fillPaint.setColor(0xccccffcc);\r\n\r\n        outlinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n        outlinePaint.setColor(0xffcccccc);\r\n\r\n\r\n        // Load the checkerboard pieces\r\n\r\n        //pieces.add( new CheckerPiece(context, R.drawable.spartan_green, 12) );\r\n\r\n        //Load green pieces\r\n        for(int i = 0; i<12; i++){\r\n            pieces.add(new CheckerPiece(context, R.drawable.spartan_green, i, 1));\r\n        }\r\n\r\n         //Load white pieces\r\n        for(int i = 0; i<12; i++){\r\n            pieces.add(new CheckerPiece(context, R.drawable.spartan_white, 31-i, 2));\r\n        }\r\n\r\n    }\r\n\r\n    public void draw(Canvas canvas){\r\n        int wid = canvas.getWidth();\r\n        int hit = canvas.getHeight();\r\n\r\n        // Determine the minimum of the two dimensions\r\n        int minDim = wid < hit ? wid : hit;\r\n\r\n        checkerSize = (int)(minDim * SCALE_IN_VIEW);\r\n\r\n        // Compute the margins so we center the puzzle\r\n        marginX = (wid - checkerSize) / 2;\r\n        marginY = (hit - checkerSize) / 2;\r\n        //\r\n        // Draw the outline of the puzzle\r\n        //\r\n\r\n        scaleFactor = (float)checkerSize;\r\n\r\n        canvas.drawRect(marginX, marginY,\r\n                marginX + checkerSize, marginY + checkerSize, fillPaint);\r\n\r\n        for(int i = 0; i < 8; i++){\r\n            drawColumn(canvas, i);\r\n        }\r\n\r\n        //\r\n        // draw the actual pieces\r\n        //\r\n        for(CheckerPiece piece : pieces){\r\n            piece.draw(canvas, marginX, marginY, checkerSize, scaleFactor);\r\n        }\r\n\r\n    }\r\n\r\n    public void drawColumn(Canvas canvas, int columnIndex){\r\n        int wid = canvas.getWidth();\r\n        int hit = canvas.getHeight();\r\n\r\n        // Determine the minimum of the two dimensions\r\n        int minDim = wid < hit ? wid : hit;\r\n\r\n        int puzzleSize = (int)(minDim * SCALE_IN_VIEW);\r\n\r\n        // Compute the margins so we center the puzzle\r\n        int marginX = (wid - puzzleSize) / 2;\r\n        int marginY = (hit - puzzleSize) / 2;\r\n\r\n        for(int i = 0; i< 8; i++){\r\n             int squareCenterXOffset = marginX + columnIndex * puzzleSize/8;\r\n             int squareCenterYOffset = marginY + i * puzzleSize/8;\r\n\r\n             if ((i + columnIndex) % 2 == 1){\r\n                 fillPaint.setColor(darkSquare);\r\n             }\r\n             else{\r\n                 fillPaint.setColor(lightSquare);\r\n             }\r\n\r\n            canvas.drawRect(squareCenterXOffset, squareCenterYOffset,\r\n                    squareCenterXOffset + puzzleSize/8, squareCenterYOffset + puzzleSize/8, fillPaint);\r\n        }\r\n    }\r\n\r\n    private boolean onTouched(float x, float y) {\r\n\r\n        // Check each piece to see if it has been hit\r\n        // We do this in reverse order so we find the pieces in front\r\n        for(int p=pieces.size()-1; p>=0;  p--) {\r\n            if(pieces.get(p).hit(x, y, checkerSize, SCALE_IN_VIEW, marginX, marginY)\r\n                && activePlayer == pieces.get(p).access) {\r\n                // We hit a piece!\r\n\r\n                //dragging = pieces.get(pieces.size()-1);\r\n                dragging = pieces.get(p);\r\n                dragging.isGrabbed = true;\r\n                lastRelX = x;\r\n                lastRelY = y;\r\n                //PuzzlePiece t = pieces.get(pieces.size()-1);\r\n                //pieces.set(p, t);\r\n                //pieces.set(pieces.size()-1, dragging);\r\n                pieces.add(pieces.size(), dragging);\r\n                pieces.remove(p);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /*\r\n     * Handle a touch event from the view.\r\n     * @param view The view that is the source of the touch\r\n     * @param event The motion event describing the touch\r\n     * @return true if the touch is handled.\r\n    *\r\n    */\r\n\r\n    public boolean onTouchEvent(View view, MotionEvent event) {\r\n\r\n        // Convert an x,y location to a relative location in the\r\n        // puzzle.\r\n        //\r\n        float relX = (event.getX()) / (checkerSize + marginX*2);\r\n        float relY = (event.getY()) / (checkerSize + marginY*2);\r\n\r\n        switch (event.getActionMasked()) {\r\n\r\n            case MotionEvent.ACTION_DOWN:\r\n                return onTouched(relX, relY);\r\n\r\n            case MotionEvent.ACTION_UP:\r\n            case MotionEvent.ACTION_CANCEL:\r\n                return onReleased(view, relX, relY);\r\n\r\n\r\n            case MotionEvent.ACTION_MOVE:\r\n                // If we are dragging, move the piece and force a redraw\r\n                if(dragging != null) {\r\n                    //check if valid\r\n                    //dragging.dx = 500;\r\n                    dragging.move(relX - lastRelX, relY - lastRelY);\r\n                    //dragging.move(lastRelX, lastRelY);\r\n                    lastRelX = relX;\r\n                    lastRelY = relY;\r\n\r\n                    view.invalidate();\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Handle a release of a touch message.\r\n     * @param x x location for the touch release, relative to the puzzle - 0 to 1 over the puzzle\r\n     * @param y y location for the touch release, relative to the puzzle - 0 to 1 over the puzzle\r\n     * @return true if the touch is handled\r\n     */\r\n    private boolean onReleased(View view, float x, float y) {\r\n\r\n        if(dragging != null) {\r\n            for (int p=pieces.size()-1; p>=0;  p--){\r\n                CheckerPiece test1 = pieces.get(p);\r\n                int proposedIndex = dragging.calculateIndex(marginX, marginY, checkerSize);\r\n                int currentIndex = test1.calculateIndex(marginX, marginY, checkerSize);\r\n\r\n                if (dragging.locationIndex == pieces.get(p).locationIndex) {\r\n                    if (dragging.locationIndex == pieces.get(p).locationIndex) {\r\n                        //true\r\n                        if (pieces.get(p) != dragging) {\r\n                            return false;\r\n                        }\r\n                        //pieces.remove(p);\r\n                        //return false;\r\n                    }\r\n                }\r\n            }\r\n            if(dragging.maybeSnap(marginX, marginY, checkerSize)) {\r\n                // We have snapped into place\r\n\r\n                // check if there is  a  piece in the way\r\n                boolean locationOccupied = false;\r\n                for(CheckerPiece piece : pieces){\r\n                    if(piece.locationIndex == dragging.calculateIndex(marginX,  marginY,  checkerSize)){\r\n                        locationOccupied = true;\r\n                    }\r\n                }\r\n\r\n                if(!locationOccupied)  {\r\n                    dragging.locationIndex = dragging.calculateIndex(marginX, marginY, checkerSize);\r\n\r\n                    if(isDone()) {\r\n                        // The puzzle is done\r\n\r\n                    }\r\n                    else{\r\n                        switchTurn(view);\r\n                    }\r\n                }\r\n                else{\r\n                    // move failed\r\n                }\r\n\r\n\r\n                view.invalidate();\r\n            }\r\n            dragging.isGrabbed = false;\r\n            dragging = null;\r\n\r\n            view.invalidate();\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if the puzzle is done!\r\n     * @return true if puzzle is done\r\n     */\r\n    public boolean isDone() {\r\n        if (pieces.isEmpty()) return true;\r\n        return false;\r\n    }\r\n\r\n    private void switchTurn(View view){\r\n        // swap current player\r\n        activePlayer = activePlayer == 1 ? 2 : 1;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java	(revision a6ecc386c5eed9628cd85f2e6dfacedbe815d513)
+++ app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java	(date 1604444856448)
@@ -297,19 +297,22 @@
                     }
                 }
             }
+            int potentialIndex = dragging.calculateIndex(marginX,  marginY,  checkerSize);
             if(dragging.maybeSnap(marginX, marginY, checkerSize)) {
                 // We have snapped into place
 
                 // check if there is  a  piece in the way
                 boolean locationOccupied = false;
+                //int potentialIndex = dragging.calculateIndex(marginX,  marginY,  checkerSize);
                 for(CheckerPiece piece : pieces){
-                    if(piece.locationIndex == dragging.calculateIndex(marginX,  marginY,  checkerSize)){
+                    if(piece.locationIndex == potentialIndex){
                         locationOccupied = true;
+                        break;
                     }
                 }
 
                 if(!locationOccupied)  {
-                    dragging.locationIndex = dragging.calculateIndex(marginX, marginY, checkerSize);
+                    dragging.updateIndex(potentialIndex, marginX, marginY, checkerSize);
 
                     if(isDone()) {
                         // The puzzle is done
@@ -320,11 +323,56 @@
                     }
                 }
                 else{
-                    // move failed
+                    // if move fails, reset x and y
+
+
                 }
 
 
                 view.invalidate();
+            }
+            else if(!(potentialIndex<0 || potentialIndex>31) ) {
+                // check for jump before failure
+                //int potentialIndex = dragging.calculateIndex(marginX,  marginY,  checkerSize);
+                int potentialJumpee = -1;
+                switch(dragging.locationIndex - potentialIndex){
+                    case 7:
+                        if( (dragging.locationIndex/4)%2 == 0 ){
+                            // if player 1, use 4 if player 2 use 3
+                            potentialJumpee = dragging.access == 1 ? 4 : 3;
+                        }
+                        else{
+                            // if player 1, use 3 if player 2 use 4
+                            potentialJumpee = dragging.access == 1 ? 3 : 4;
+                        }
+                        break;
+                    case 9:
+                        if( (dragging.locationIndex/4)%2 == 0 ){
+                            // if player 1, use 4 if player 2 use 5
+                            potentialJumpee = dragging.access == 1 ? 5 : 4;
+                        }
+                        else{
+                            // if player 1, use 5 if player 2 use 4
+                            potentialJumpee = dragging.access == 1 ? 4 : 5;
+                        }
+                        break;
+                }
+                if(!(potentialJumpee == -1)){  // if valid and/or not
+                    for(CheckerPiece piece : pieces){
+                        if( (dragging.access == 1 && (dragging.locationIndex + potentialJumpee) == piece.locationIndex)
+                         || (dragging.access == 2 && (dragging.locationIndex - potentialJumpee) == piece.locationIndex))
+                        {
+                            // kill piece
+                            pieces.remove(piece);
+                            // move dragging
+                            dragging.updateIndex(potentialIndex, marginX, marginY, checkerSize);
+                            switchTurn(view);
+                            break;
+                        }
+                    }
+
+                }
+
             }
             dragging.isGrabbed = false;
             dragging = null;
