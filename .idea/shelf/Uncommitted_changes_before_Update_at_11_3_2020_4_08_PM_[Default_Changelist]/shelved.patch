Index: app/src/main/java/edu/msu/hagopi10/project1/CheckerPiece.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.msu.hagopi10.project1;\r\n\r\nimport android.content.Context;\r\nimport android.database.CrossProcessCursorWrapper;\r\nimport android.graphics.Bitmap;\r\nimport android.graphics.BitmapFactory;\r\nimport android.graphics.Canvas;\r\nimport java.util.Random;\r\nimport android.graphics.Paint;\r\n\r\nimport java.util.ArrayList;\r\nimport java.util.Random;\r\n\r\npublic class CheckerPiece {\r\n    /**\r\n     * THe image for the actual piece.\r\n     */\r\n    private Bitmap piece;\r\n\r\n    public float getX() {\r\n        return x;\r\n    }\r\n\r\n    public void setX(float x) {\r\n        this.x = x;\r\n    }\r\n\r\n    public float getY() {\r\n        return y;\r\n    }\r\n\r\n    public void setY(float y) {\r\n        this.y = y;\r\n    }\r\n\r\n    public int getId() {\r\n        return id;\r\n    }\r\n\r\n    /**\r\n     * The piece ID\r\n     */\r\n    private int id;\r\n\r\n    /**\r\n     * x location.\r\n     * We use relative x locations in the range 0-1 for the center\r\n     * of the puzzle piece.\r\n     */\r\n    private float x = 0;\r\n\r\n    /**\r\n     * y location\r\n     */\r\n    private float y = 0;\r\n\r\n    /**\r\n     * x location when the puzzle is solved\r\n     */\r\n    private float finalX;\r\n\r\n    /**\r\n     * y location when the puzzle is solved\r\n     */\r\n    private float finalY;\r\n\r\n    /**\r\n     * y location when the puzzle is solved\r\n     */\r\n    private Paint textPaint;\r\n\r\n    /**\r\n     * We consider a piece to be in the right location if within\r\n     * this distance.\r\n     */\r\n    final static float SNAP_DISTANCE = .07f;\r\n\r\n    /**\r\n     * What square the piece is in, starts counting from the top, leftmost, square, counts right\r\n     * until the end of the row then loops to the leftmost square on the next row and continues\r\n     * counting\r\n     */\r\n    public int locationIndex;\r\n\r\n    /**\r\n     * True when the piece has been picked up to move\r\n     */\r\n    public boolean isGrabbed;\r\n\r\n    /**\r\n     * Which player can grab this piece\r\n     * 1 is player 1, 2 is player 2\r\n     */\r\n    public int access;\r\n\r\n    public CheckerPiece(Context context, int id, int boardIndex, int access) {\r\n        this.locationIndex = boardIndex;\r\n        this.id = id;\r\n        this.access = access;\r\n\r\n        piece = BitmapFactory.decodeResource(context.getResources(), id);\r\n\r\n    }\r\n\r\n    public void draw(Canvas canvas, int marginX, int marginY,\r\n                     int puzzleSize, float scaleFactor){\r\n\r\n        if (!isGrabbed) setLocationFromIndex(locationIndex, marginX, marginY, puzzleSize);\r\n\r\n        canvas.save();\r\n\r\n        // Convert x,y to pixels and add the margin, then draw\r\n        canvas.translate(x * (puzzleSize + 2*marginX), y * (puzzleSize + 2*marginY));\r\n\r\n        scaleFactor = (puzzleSize/8.0f)/(float)Math.min(piece.getHeight(), piece.getWidth());\r\n\r\n        // Scale it to the right size\r\n        canvas.scale(scaleFactor, scaleFactor);\r\n\r\n        // This magic code makes the center of the piece at 0, 0\r\n        canvas.translate(-piece.getWidth() / 2f, -piece.getHeight() / 2f);\r\n\r\n        // Draw the bitmap\r\n        canvas.drawBitmap(piece, 0, 0, null);\r\n        canvas.restore();\r\n\r\n    }\r\n\r\n    /**\r\n     * Test to see if we have touched a puzzle piece\r\n     * @param testX X location as a normalized coordinate (0 to 1)\r\n     * @param testY Y location as a normalized coordinate (0 to 1)\r\n     * @param puzzleSize the size of the puzzle in pixels\r\n     * @param scaleFactor the amount to scale a piece by\r\n     * @return true if we hit the piece\r\n     */\r\n    public boolean hit(float testX, float testY,\r\n                       int puzzleSize, float scaleFactor, int marginX, int marginY) {\r\n\r\n        // Make relative to the location and size to the piece size\r\n        scaleFactor = (puzzleSize/8.0f)/(float)Math.min(piece.getHeight(), piece.getWidth());\r\n\r\n        int pX = (int)(( ((testX - x) * (puzzleSize + marginX*2)) +\r\n                piece.getWidth() * 3f/8f));\r\n        int pY = (int)(( ((testY - y) * (puzzleSize + marginY*2)) +\r\n                piece.getHeight() * 3f/8f));\r\n\r\n        if(pX < 0 || pX >= piece.getWidth()/2 ||\r\n                pY < 0 || pY >= piece.getHeight()/2) {\r\n            return false;\r\n        }\r\n\r\n        // We are within the rectangle of the piece.\r\n        // Are we touching actual picture?\r\n        return (piece.getPixel(pX, pY) & 0xff000000) != 0;\r\n\r\n    }\r\n\r\n    /**\r\n     * Move the puzzle piece by dx, dy\r\n     * @param dx x amount to move\r\n     * @param dy y amount to move\r\n     */\r\n    public void move(float dx, float dy) {\r\n        x += dx;\r\n        y += dy;\r\n    }\r\n\r\n    public void setLocationFromIndex(int index, int marginX, int marginY, int puzzleSize){\r\n        int xIndex; int yIndex;\r\n        xIndex = index%4;\r\n        yIndex = index/4;\r\n\r\n        // Convert x,y to pixels and add the margin, then draw\r\n        if( yIndex%2 == 0 ){\r\n            x = (float) (marginX + xIndex * puzzleSize/4 + puzzleSize * 3/16) / (float) (puzzleSize + 2*marginX);\r\n            y = (float) (marginY + yIndex * puzzleSize/8 + puzzleSize/16) / (float) (puzzleSize + 2*marginY);\r\n        }\r\n        else{\r\n            x = (float) (marginX + xIndex * puzzleSize/4 + puzzleSize/16) / (float) (puzzleSize + 2*marginX);\r\n            y = (float) (marginY + yIndex * puzzleSize/8 + puzzleSize/16) / (float) (puzzleSize + 2*marginY);\r\n        }\r\n\r\n    }\r\n\r\n    public int calculateIndex(int marginX, int marginY, int puzzleSize) {\r\n\r\n        int colIndex; int rowIndex;\r\n        //gets row (y) index\r\n        rowIndex = (int) (((float) ((y)*(puzzleSize + 2*marginY) - marginY) / (float) (puzzleSize/8)));\r\n\r\n        // find column (x) index based on if it should be shifted over\r\n        if( rowIndex%2 == 0 ){\r\n            colIndex = (int) ((x*(puzzleSize + 2*marginX) - marginX) / (puzzleSize/4));\r\n\r\n        }\r\n        else{\r\n            colIndex = (int) ((x*(puzzleSize + 2*marginX) + (puzzleSize* 1/16) - marginX) / (puzzleSize/4));\r\n        }\r\n\r\n        return rowIndex*4 + colIndex;\r\n    }\r\n\r\n    public boolean isValid(int index) {\r\n        //compute if there is a piece at index.\r\n        //if there is friendly piece at index, return false\r\n        //else, there must be either no piece or an enemy piece\r\n        //if there is an enemy piece, delete that piece, and return true\r\n        //if there is no piece, return true\r\n        return true;\r\n    }\r\n    /**\r\n     * If we are within SNAP_DISTANCE of the correct\r\n     * answer, snap to the correct answer exactly.\r\n     * @return\r\n     */\r\n    public boolean maybeSnap(int marginX, int marginY, int puzzleSize) {\r\n\r\n\r\n        int index = calculateIndex(marginX, marginY, puzzleSize);\r\n\r\n        // location must be greater than 0\r\n        // if player 1 and piece isn't a king, it must move down\r\n        // if player 2 and piece isn't a king, it must move upward\r\n        if(index >= 0\r\n                && ((access == 1 && index/4 > locationIndex/4)\r\n                ||  (access == 2 && index/4 < locationIndex/4))\r\n          )\r\n        {\r\n\r\n            locationIndex = index;\r\n            if (isValid(index)) {\r\n                return true;\r\n            }\r\n\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if this piece is snapped in place\r\n     * @return true if snapped into place\r\n     */\r\n    public boolean isSnapped() {\r\n        if (x == finalX && y == finalY) {\r\n            return true;\r\n        }\r\n        return false;\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/msu/hagopi10/project1/CheckerPiece.java	(revision cffe62e1fcf82ef4e9f0d0dfaf801eaf6302dfa8)
+++ app/src/main/java/edu/msu/hagopi10/project1/CheckerPiece.java	(date 1604437724803)
@@ -223,12 +223,11 @@
         // if player 1 and piece isn't a king, it must move down
         // if player 2 and piece isn't a king, it must move upward
         if(index >= 0
-                && ((access == 1 && index/4 > locationIndex/4)
-                ||  (access == 2 && index/4 < locationIndex/4))
-          )
+                && ((access == 1 && index/4 > locationIndex/4 && (index ==  locationIndex+4 || index == locationIndex+5))
+                ||  (access == 2 && index/4 < locationIndex/4 && (index ==  locationIndex-4 || index == locationIndex-5))))
         {
 
-            locationIndex = index;
+
             if (isValid(index)) {
                 return true;
             }
@@ -248,4 +247,11 @@
         }
         return false;
     }
+
+    /**
+     * words
+     */
+    public void updateIndex(int index){
+        locationIndex = index;
+    }
 }
Index: app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package edu.msu.hagopi10.project1;\r\n\r\n\r\nimport android.content.Context;\r\nimport android.graphics.Canvas;\r\nimport android.graphics.Paint;\r\nimport android.view.MotionEvent;\r\nimport android.view.View;\r\n\r\nimport java.util.Random;\r\n\r\nimport android.widget.TextView;\r\n\r\n\r\nimport java.util.ArrayList;\r\n\r\n/**\r\n * This class represents our checkerboard.\r\n */\r\npublic class CheckerBoard {\r\n\r\n    private Paint textPaint;\r\n    /**\r\n     * Paint for filling the area the checkerboard is in\r\n     */\r\n    private Paint fillPaint;\r\n\r\n    /**\r\n     * Paint for outlining the area the checkerboard is in\r\n     */\r\n    private Paint outlinePaint;\r\n    \r\n\r\n    /**\r\n     * The size of the checkerboard in pixels\r\n     */\r\n    private int checkerSize;\r\n\r\n    /**\r\n     * How much we scale the checkerboard pieces\r\n     */\r\n    private float scaleFactor;\r\n\r\n    /**\r\n     * Left margin in pixels\r\n     */\r\n    private int marginX;\r\n\r\n    /**\r\n     * Top margin in pixels\r\n     */\r\n    private int marginY;\r\n\r\n    private float xCoordinate;\r\n\r\n    private float yCoordinate;\r\n\r\n    /**\r\n     * Most recent relative X touch when dragging\r\n     */\r\n    private float lastRelX;\r\n\r\n    //gameSize = int(minDim) * SCALE_IN_VIEW;\r\n\r\n    //blockSize = gameSize /8\r\n    /**\r\n     * Most recent relative Y touch when dragging\r\n     */\r\n    private float lastRelY;\r\n\r\n    /**\r\n     * Collection of checkerboard pieces\r\n     */\r\n    public ArrayList<CheckerPiece> pieces = new ArrayList< >();\r\n\r\n    /**\r\n     * This variable is set to a piece we are dragging. If\r\n     * we are not dragging, the variable is null.\r\n     */\r\n    private CheckerPiece dragging = null;\r\n\r\n    /**\r\n     * Percentage of the display width or height that\r\n     * is occupied by the checkerboard.\r\n     */\r\n    final static float SCALE_IN_VIEW = 0.9f;\r\n\r\n    /**\r\n     * Random number generator\r\n     */\r\n    private static Random random = new Random();\r\n\r\n    /**\r\n     * The name of the bundle keys to save the checkerboard\r\n     */\r\n    private final static String LOCATIONS = \"checkerboard.locations\";\r\n    private final static String IDS = \"checkerboard.ids\";\r\n\r\n    /**\r\n     * Paint color we will use to draw dark checker squares\r\n     */\r\n    private int darkSquare = 0xff779455;\r\n\r\n    /**\r\n     * Paint color we will use to draw light checker squares\r\n     */\r\n    private int lightSquare = 0xffebebd0;\r\n\r\n    /**\r\n     * Current player to make a move\r\n     * 1 = player 1\r\n     * 2 = player 2\r\n     * Starts game with player 1\r\n     */\r\n    private int activePlayer = 1;\r\n\r\n    public CheckerBoard(Context context) {\r\n\r\n        // Create paint for filling the area the checkerboard will\r\n        // be solved in.\r\n        fillPaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n        fillPaint.setColor(0xccccffcc);\r\n\r\n        outlinePaint = new Paint(Paint.ANTI_ALIAS_FLAG);\r\n        outlinePaint.setColor(0xffcccccc);\r\n\r\n\r\n        // Load the checkerboard pieces\r\n\r\n        //pieces.add( new CheckerPiece(context, R.drawable.spartan_green, 12) );\r\n\r\n        //Load green pieces\r\n        for(int i = 0; i<12; i++){\r\n            pieces.add(new CheckerPiece(context, R.drawable.spartan_green, i, 1));\r\n        }\r\n\r\n         //Load white pieces\r\n        for(int i = 0; i<12; i++){\r\n            pieces.add(new CheckerPiece(context, R.drawable.spartan_white, 31-i, 2));\r\n        }\r\n\r\n    }\r\n\r\n    public void draw(Canvas canvas){\r\n        int wid = canvas.getWidth();\r\n        int hit = canvas.getHeight();\r\n\r\n        // Determine the minimum of the two dimensions\r\n        int minDim = wid < hit ? wid : hit;\r\n\r\n        checkerSize = (int)(minDim * SCALE_IN_VIEW);\r\n\r\n        // Compute the margins so we center the puzzle\r\n        marginX = (wid - checkerSize) / 2;\r\n        marginY = (hit - checkerSize) / 2;\r\n        //\r\n        // Draw the outline of the puzzle\r\n        //\r\n\r\n        scaleFactor = (float)checkerSize;\r\n\r\n        canvas.drawRect(marginX, marginY,\r\n                marginX + checkerSize, marginY + checkerSize, fillPaint);\r\n\r\n        for(int i = 0; i < 8; i++){\r\n            drawColumn(canvas, i);\r\n        }\r\n\r\n        //\r\n        // draw the actual pieces\r\n        //\r\n        for(CheckerPiece piece : pieces){\r\n            piece.draw(canvas, marginX, marginY, checkerSize, scaleFactor);\r\n        }\r\n\r\n    }\r\n\r\n    public void drawColumn(Canvas canvas, int columnIndex){\r\n        int wid = canvas.getWidth();\r\n        int hit = canvas.getHeight();\r\n\r\n        // Determine the minimum of the two dimensions\r\n        int minDim = wid < hit ? wid : hit;\r\n\r\n        int puzzleSize = (int)(minDim * SCALE_IN_VIEW);\r\n\r\n        // Compute the margins so we center the puzzle\r\n        int marginX = (wid - puzzleSize) / 2;\r\n        int marginY = (hit - puzzleSize) / 2;\r\n\r\n        for(int i = 0; i< 8; i++){\r\n             int squareCenterXOffset = marginX + columnIndex * puzzleSize/8;\r\n             int squareCenterYOffset = marginY + i * puzzleSize/8;\r\n\r\n             if ((i + columnIndex) % 2 == 1){\r\n                 fillPaint.setColor(darkSquare);\r\n             }\r\n             else{\r\n                 fillPaint.setColor(lightSquare);\r\n             }\r\n\r\n            canvas.drawRect(squareCenterXOffset, squareCenterYOffset,\r\n                    squareCenterXOffset + puzzleSize/8, squareCenterYOffset + puzzleSize/8, fillPaint);\r\n        }\r\n    }\r\n\r\n    private boolean onTouched(float x, float y) {\r\n\r\n        // Check each piece to see if it has been hit\r\n        // We do this in reverse order so we find the pieces in front\r\n        for(int p=pieces.size()-1; p>=0;  p--) {\r\n            if(pieces.get(p).hit(x, y, checkerSize, SCALE_IN_VIEW, marginX, marginY)\r\n                && activePlayer == pieces.get(p).access) {\r\n                // We hit a piece!\r\n\r\n                //dragging = pieces.get(pieces.size()-1);\r\n                dragging = pieces.get(p);\r\n                dragging.isGrabbed = true;\r\n                lastRelX = x;\r\n                lastRelY = y;\r\n                //PuzzlePiece t = pieces.get(pieces.size()-1);\r\n                //pieces.set(p, t);\r\n                //pieces.set(pieces.size()-1, dragging);\r\n                pieces.add(pieces.size(), dragging);\r\n                pieces.remove(p);\r\n                return true;\r\n            }\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n\r\n    /*\r\n     * Handle a touch event from the view.\r\n     * @param view The view that is the source of the touch\r\n     * @param event The motion event describing the touch\r\n     * @return true if the touch is handled.\r\n    *\r\n    */\r\n\r\n    public boolean onTouchEvent(View view, MotionEvent event) {\r\n\r\n        // Convert an x,y location to a relative location in the\r\n        // puzzle.\r\n        //\r\n        xCoordinate = event.getX();\r\n        yCoordinate = event.getY();\r\n\r\n        float relX = (event.getX()) / (checkerSize + marginX*2);\r\n        float relY = (event.getY()) / (checkerSize + marginY*2);\r\n\r\n        switch (event.getActionMasked()) {\r\n\r\n            case MotionEvent.ACTION_DOWN:\r\n                return onTouched(relX, relY);\r\n\r\n            case MotionEvent.ACTION_UP:\r\n            case MotionEvent.ACTION_CANCEL:\r\n                return onReleased(view, relX, relY);\r\n\r\n\r\n            case MotionEvent.ACTION_MOVE:\r\n                // If we are dragging, move the piece and force a redraw\r\n                if(dragging != null) {\r\n                    //check if valid\r\n                    //dragging.dx = 500;\r\n                    dragging.move(relX - lastRelX, relY - lastRelY);\r\n                    //dragging.move(lastRelX, lastRelY);\r\n                    lastRelX = relX;\r\n                    lastRelY = relY;\r\n\r\n                    view.invalidate();\r\n                    return true;\r\n                }\r\n                break;\r\n        }\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Handle a release of a touch message.\r\n     * @param x x location for the touch release, relative to the puzzle - 0 to 1 over the puzzle\r\n     * @param y y location for the touch release, relative to the puzzle - 0 to 1 over the puzzle\r\n     * @return true if the touch is handled\r\n     */\r\n    private boolean onReleased(View view, float x, float y) {\r\n\r\n        if(dragging != null) {\r\n            for (int p=pieces.size()-1; p>=0;  p--){\r\n                if (dragging.locationIndex == pieces.get(p).locationIndex) {\r\n                    if (dragging != pieces.get(p)) {\r\n                        //pieces.remove(p);\r\n                        //return false;\r\n                    }\r\n                }\r\n            }\r\n            if(dragging.maybeSnap(marginX, marginY, checkerSize)) {\r\n                // We have snapped into place\r\n\r\n\r\n\r\n                if(isDone()) {\r\n                    // The puzzle is done\r\n\r\n                }\r\n                else{\r\n                    switchTurn(view);\r\n                }\r\n                view.invalidate();\r\n            }\r\n            dragging.isGrabbed = false;\r\n            dragging = null;\r\n\r\n            view.invalidate();\r\n            return true;\r\n        }\r\n\r\n        return false;\r\n    }\r\n\r\n    /**\r\n     * Determine if the puzzle is done!\r\n     * @return true if puzzle is done\r\n     */\r\n    public boolean isDone() {\r\n        if (pieces.isEmpty()) return true;\r\n        return false;\r\n    }\r\n\r\n    private void switchTurn(View view){\r\n        // swap current player\r\n        activePlayer = activePlayer == 1 ? 2 : 1;\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
--- app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java	(revision cffe62e1fcf82ef4e9f0d0dfaf801eaf6302dfa8)
+++ app/src/main/java/edu/msu/hagopi10/project1/CheckerBoard.java	(date 1604437724798)
@@ -298,7 +298,17 @@
             if(dragging.maybeSnap(marginX, marginY, checkerSize)) {
                 // We have snapped into place
 
+                // check if there is  a  piece in the way
+                boolean locationOccupied = false;
+                for(CheckerPiece piece : pieces){
+                    if(piece.locationIndex == dragging.calculateIndex(marginX,  marginY,  checkerSize)){
+                        locationOccupied = true;
+                    }
+                }
 
+                if(!locationOccupied)  {
+                    dragging.locationIndex = dragging.calculateIndex(marginX, marginY, checkerSize);
+                }
 
                 if(isDone()) {
                     // The puzzle is done
